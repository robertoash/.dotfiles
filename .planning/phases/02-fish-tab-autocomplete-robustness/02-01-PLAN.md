---
phase: 02-fish-tab-autocomplete-robustness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - common/config/fish/functions/__completion_config.fish
  - common/config/fish/functions/__completion_sources.fish
autonomous: true

must_haves:
  truths:
    - "Command categorization config is a single data structure, trivially extensible with new commands"
    - "Multi-source engine returns merged, deduplicated, frecency-boosted candidates for dirs, files, or both"
    - "Source merging completes in <100ms for typical directory trees"
    - "Frecency sources (zoxide for dirs, fre for files) are prioritized over raw filesystem results"
    - "Fallback to fd-only when frecency tools are unavailable"
  artifacts:
    - path: "common/config/fish/functions/__completion_config.fish"
      provides: "Command categorization data + context detection logic"
      contains: "__completion_get_type"
    - path: "common/config/fish/functions/__completion_sources.fish"
      provides: "Multi-source candidate generation engine"
      contains: "__completion_sources"
  key_links:
    - from: "common/config/fish/functions/__completion_sources.fish"
      to: "zoxide query -l"
      via: "command substitution for directory frecency"
      pattern: "zoxide query"
    - from: "common/config/fish/functions/__completion_sources.fish"
      to: "fre --sorted"
      via: "command substitution for file frecency"
      pattern: "fre --sorted"
    - from: "common/config/fish/functions/__completion_sources.fish"
      to: "fd"
      via: "filesystem discovery fallback"
      pattern: "fd -Hi"
---

<objective>
Build the two foundation modules for the smart completion system: (1) a centralized command categorization config that determines what type of completions each command needs, and (2) a multi-source candidate generation engine that merges frecency data (zoxide, fre), fish native completions, and filesystem results (fd) with smart deduplication and prioritization.

Purpose: These modules are the data layer and engine that the Tab/Shift+Tab handlers will call. Separating them enables independent testing, clean architecture, and easy extension.

Output: Two fish function files providing command categorization and multi-source completion candidate generation.
</objective>

<execution_context>
@/home/rash/.claude/get-shit-done/workflows/execute-plan.md
@/home/rash/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-fish-tab-autocomplete-robustness/02-RESEARCH.md

# Current implementation to refactor from
@common/config/fish/functions/__smart_tab_complete.fish
@common/config/fish/functions/frecent.fish
@common/config/fish/functions/__frecent_unified_widget.fish
@common/config/fish/functions/__fd_unified_widget.fish
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create command categorization config and context detection</name>
  <files>common/config/fish/functions/__completion_config.fish</files>
  <action>
Create `__completion_config.fish` with two responsibilities:

**1. Command categorization data structure:**

Migrate and expand the command lists from `__smart_tab_complete.fish` into a cleaner, more comprehensive structure. Use fish lists for each category:

```fish
# Directory-only commands
set -g __cc_dir_cmds cd z pushd popd mkdir rmdir ls ll lll lls llr llrl eza exa tree yazi yz ranger nnn lf mc vifm broot br j jump autojump fasd

# File-only commands
set -g __cc_file_cmds vim nvim vi nano emacs micro helix hx kak cat bat batcat less more head tail view ...
# (include the full existing list from __smart_tab_complete.fish plus additions below)

# Both files AND directories
set -g __cc_both_cmds cp mv rsync rclone ln code code-insiders subl ...

# Git subcommands wanting files/paths
set -g __cc_git_file_subcmds add checkout restore diff rm mv log show blame annotate stash

# Commands that should ALWAYS use native fish completion (never fzf)
# These have rich fish completions that fzf would degrade (flags, subcommands)
set -g __cc_native_cmds git docker kubectl systemctl pacman yay paru pip cargo npm yarn brew apt dnf

# Command wrappers to strip before categorization
set -g __cc_wrapper_cmds sudo doas env nohup nice time watch strace ltrace
```

**Additions to discover and include** beyond the existing lists:
- `docker cp`, `docker run -v` (both)
- `source`, `fish_source` (files)
- `unrar`, `7z`, `atool` (both)
- `sshfs` (dirs)
- `rg --files` context (files)
- `dust`, `ncdu` (dirs)
- `eog`, `gimp`, `inkscape` (files)
- `libreoffice`, `soffice` (files)
- `code`, `codium` (both)
- `ansible-playbook` (files)
- `terraform`, `terragrunt` (files)

**2. Context detection function `__completion_get_type`:**

```fish
function __completion_get_type
    # Returns one of: dirs, files, both, native, trigger:ff, trigger:dd, trigger:aa, trigger:fff, trigger:fdd, trigger:faa, empty

    set -l cmd (commandline -b)
    set -l token (commandline -t)
    set -l tokens (commandline -xpc)  # Use fish's proper tokenizer (handles quoting)

    # Handle trigger words FIRST (before any other logic)
    switch "$token"
        case ff; echo "trigger:ff"; return
        case dd; echo "trigger:dd"; return
        case aa; echo "trigger:aa"; return
    end
    if string match -q -r '^f(ff|dd|aa)$' -- "$token"
        echo "trigger:$token"; return
    end

    # Empty command line -> native completion
    if test (count $tokens) -eq 0
        echo "native"; return
    end

    # Extract base command, stripping wrappers
    set -l base_cmd (basename -- $tokens[1])
    if contains $base_cmd $__cc_wrapper_cmds
        if test (count $tokens) -ge 2
            set base_cmd (basename -- $tokens[2])
        else
            echo "native"; return
        end
    end

    # If we're still on the command itself (no space after it), use native
    if test (count $tokens) -lt 2; and test -z "$token"
        echo "native"; return
    end

    # Special: git subcommand detection
    if test "$base_cmd" = git; and test (count $tokens) -ge 2
        if contains $tokens[2] $__cc_git_file_subcmds
            echo "both"; return
        end
        echo "native"; return
    end

    # Special: remote path detection (host:path pattern)
    if string match -q '*:*' -- "$token"
        # Only if a remote-capable command
        if contains $base_cmd scp rsync ssh sftp
            echo "remote"; return
        end
    end

    # Categorize by command lists
    if contains $base_cmd $__cc_native_cmds
        echo "native"
    else if contains $base_cmd $__cc_dir_cmds
        echo "dirs"
    else if contains $base_cmd $__cc_file_cmds
        echo "files"
    else if contains $base_cmd $__cc_both_cmds
        echo "both"
    else
        # Unknown command: default to "both" (files + dirs is safest)
        echo "both"
    end
end
```

**UX design decisions embedded in this config:**

1. **Unknown commands default to "both"** (files+dirs) rather than "native" -- because fzf is generally more useful than fish's default pager for path completion. The user gets both file and directory results, which is the safest bet for unknown commands.

2. **"native" category exists for flag-heavy commands** (git, docker, systemctl, pacman, etc.) where fish's built-in completions provide flags, subcommands, and options that fzf would lose. The smart Tab system yields to fish for these.

3. **Trigger words checked FIRST** so they work regardless of command context. `nvim ff+Tab` works the same as `cd ff+Tab`.

4. **Wrapper stripping** handles `sudo nvim +Tab` correctly by looking past sudo to nvim.

5. **Remote detection** checks for `:` in token but ONLY for remote-capable commands, preventing false positives on paths with colons.
  </action>
  <verify>
Source the file in fish: `source common/config/fish/functions/__completion_config.fish`

Verify data structures are set:
- `echo $__cc_dir_cmds | grep -c " "` returns > 15 (many commands)
- `echo $__cc_file_cmds | grep -c " "` returns > 40

Test context detection:
- `commandline -r "cd "; __completion_get_type` -> "dirs"
- `commandline -r "nvim "; __completion_get_type` -> "files"
- `commandline -r "git add "; __completion_get_type` -> "both"
- `commandline -r "docker "; __completion_get_type` -> "native"
- `commandline -r ""; __completion_get_type` -> "native"
  </verify>
  <done>
__completion_config.fish exists with comprehensive command categorization covering 100+ commands across 5 categories (dirs, files, both, native, wrapper), trigger word detection, wrapper stripping, git subcommand handling, and remote path detection. The function __completion_get_type returns the correct type for all tested command contexts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create multi-source completion candidate engine</name>
  <files>common/config/fish/functions/__completion_sources.fish</files>
  <action>
Create `__completion_sources.fish` with the core function `__completion_sources` that generates merged, deduplicated, prioritized completion candidates.

```fish
function __completion_sources --argument-names type search_dir query_part
    # type: "dirs", "files", or "both"
    # search_dir: directory to search in (default ".")
    # query_part: partial text the user has typed (for fzf --query, not for filtering here)
    #
    # Outputs candidates to stdout, one per line, ordered by priority:
    #   1. Frecency results (zoxide for dirs, fre for files)
    #   2. Filesystem results via fd (shallow first, then deep)
    #
    # The caller pipes this into fzf.

    test -z "$search_dir"; and set search_dir "."

    set -l candidates

    switch $type
        case dirs
            # Source 1: zoxide frecency (dirs only)
            if command -q zoxide; and test "$search_dir" = "."
                # Only use zoxide for CWD-relative completion (not when searching a specific path)
                set -a candidates (zoxide query -l 2>/dev/null | head -n 30)
            end

            # Source 2: fd filesystem (shallow then deep)
            set -a candidates (fd -Hi --no-ignore-vcs -t d --max-depth 1 . "$search_dir" 2>/dev/null)
            set -a candidates (fd -Hi --no-ignore-vcs -t d --min-depth 2 --max-depth 5 . "$search_dir" 2>/dev/null)

        case files
            # Source 1: fre frecency (files only)
            if command -q fre; and test "$search_dir" = "."
                set -a candidates (fre --sorted 2>/dev/null | head -n 30)
            end

            # Source 2: fd filesystem (shallow then deep)
            set -a candidates (fd -Hi --no-ignore-vcs -t f --max-depth 1 . "$search_dir" 2>/dev/null)
            set -a candidates (fd -Hi --no-ignore-vcs -t f --min-depth 2 --max-depth 5 . "$search_dir" 2>/dev/null)

        case both
            # Source 1: frecency (both zoxide and fre)
            if command -q zoxide; and test "$search_dir" = "."
                set -a candidates (zoxide query -l 2>/dev/null | head -n 15)
            end
            if command -q fre; and test "$search_dir" = "."
                set -a candidates (fre --sorted 2>/dev/null | head -n 15)
            end

            # Source 2: fd filesystem (shallow then deep, both types)
            set -a candidates (fd -Hi --no-ignore-vcs --max-depth 1 . "$search_dir" 2>/dev/null)
            set -a candidates (fd -Hi --no-ignore-vcs --min-depth 2 --max-depth 5 . "$search_dir" 2>/dev/null)
    end

    # Deduplicate while preserving priority order (first occurrence wins)
    printf '%s\n' $candidates | awk '!seen[$0]++'
end
```

**Key design decisions:**

1. **Frecency only for CWD-relative searches:** When the user types `cd ~/Doc+Tab`, they're browsing a specific directory -- zoxide results for unrelated paths would be noise. Frecency only activates when `search_dir` is `.` (no path prefix typed).

2. **Head limits on frecency results:** zoxide and fre can return thousands of entries. Limit to 30 (solo) or 15 (combined) to keep the top section meaningful without overwhelming fzf.

3. **fd max-depth 5:** Prevents scanning enormous directory trees. Shallow results (depth 1) come first for immediate relevance, deeper results follow.

4. **Deduplication preserves priority:** `awk '!seen[$0]++'` keeps the first occurrence of each path. Since frecency results come first in the list, they naturally win over duplicate fd results.

5. **Graceful degradation:** If zoxide or fre aren't installed (`command -q` check), the function still works with fd-only results. This is critical for machines that may not have all tools installed yet.

6. **No caching in this layer:** fzf handles display efficiently via streaming. Caching would add complexity for marginal gain since frecency tools and fd are already fast.
  </action>
  <verify>
Source the file: `source common/config/fish/functions/__completion_sources.fish`

Test candidate generation:
- `__completion_sources dirs . "" | head -5` produces directory paths (should include zoxide results)
- `__completion_sources files . "" | head -5` produces file paths (should include fre results)
- `__completion_sources both . "" | wc -l` produces combined results
- `__completion_sources dirs /tmp "" | head -3` produces directories under /tmp (no zoxide since not CWD)
- `time __completion_sources dirs . ""` completes in <100ms (timing check)
  </verify>
  <done>
__completion_sources.fish exists and produces merged, deduplicated, priority-ordered completion candidates from frecency sources (zoxide/fre) and filesystem (fd). Frecency results appear first. Function works with or without frecency tools installed. Candidate generation completes in under 100ms for typical directories.
  </done>
</task>

</tasks>

<verification>
1. Both files parse without errors: `fish -n common/config/fish/functions/__completion_config.fish` and `fish -n common/config/fish/functions/__completion_sources.fish`
2. Command categorization returns correct type for: cd (dirs), nvim (files), cp (both), docker (native), git add (both)
3. Multi-source engine returns results from both frecency and filesystem sources
4. Deduplication works: paths appearing in both zoxide and fd output appear only once
5. Performance: `__completion_sources dirs . ""` completes in <100ms
</verification>

<success_criteria>
- __completion_config.fish defines categorization for 100+ commands across 5 categories
- __completion_get_type correctly categorizes all common command contexts
- __completion_sources merges zoxide/fre/fd results with proper deduplication
- Frecency results are prioritized (appear first in output)
- Graceful fallback when zoxide/fre not installed
- All functions pass fish syntax check
</success_criteria>

<output>
After completion, create `.planning/phases/02-fish-tab-autocomplete-robustness/02-01-SUMMARY.md`
</output>
