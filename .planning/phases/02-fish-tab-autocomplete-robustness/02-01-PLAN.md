---
phase: 02-fish-tab-autocomplete-robustness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - common/config/fish/functions/__completion_config.fish
  - common/config/fish/functions/__completion_sources.fish
autonomous: true

must_haves:
  truths:
    - "Command categorization config is a single data structure, trivially extensible with new commands, with xdg-mime fallback for uncategorized GUI apps"
    - "Multi-source engine returns merged, deduplicated, frecency-boosted candidates from zoxide, fre, fish history, and fd for dirs, files, or both"
    - "Source merging completes in <100ms for typical directory trees"
    - "Frecency sources (zoxide for dirs, fre for files) are prioritized over raw filesystem results"
    - "Fish history paths are extracted and merged as a completion source between frecency and filesystem results"
    - "Fallback to fd-only when frecency tools are unavailable"
  artifacts:
    - path: "common/config/fish/functions/__completion_config.fish"
      provides: "Command categorization data + context detection logic"
      contains: "__completion_get_type"
    - path: "common/config/fish/functions/__completion_sources.fish"
      provides: "Multi-source candidate generation engine"
      contains: "__completion_sources"
  key_links:
    - from: "common/config/fish/functions/__completion_sources.fish"
      to: "zoxide query -l"
      via: "command substitution for directory frecency"
      pattern: "zoxide query"
    - from: "common/config/fish/functions/__completion_sources.fish"
      to: "fre --sorted"
      via: "command substitution for file frecency"
      pattern: "fre --sorted"
    - from: "common/config/fish/functions/__completion_sources.fish"
      to: "builtin history"
      via: "fish history path extraction"
      pattern: "builtin history"
    - from: "common/config/fish/functions/__completion_sources.fish"
      to: "fd"
      via: "filesystem discovery fallback"
      pattern: "fd -Hi"
---

<objective>
Build the two foundation modules for the smart completion system: (1) a centralized command categorization config that determines what type of completions each command needs, and (2) a multi-source candidate generation engine that merges frecency data (zoxide, fre), fish history paths, and filesystem results (fd) with smart deduplication and prioritization.

Purpose: These modules are the data layer and engine that the Tab/Shift+Tab handlers will call. Separating them enables independent testing, clean architecture, and easy extension.

Output: Two fish function files providing command categorization and multi-source completion candidate generation.
</objective>

<execution_context>
@/home/rash/.claude/get-shit-done/workflows/execute-plan.md
@/home/rash/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-fish-tab-autocomplete-robustness/02-RESEARCH.md

# Current implementation to refactor from
@common/config/fish/functions/__smart_tab_complete.fish
@common/config/fish/functions/frecent.fish
@common/config/fish/functions/__frecent_unified_widget.fish
@common/config/fish/functions/__fd_unified_widget.fish
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create command categorization config and context detection</name>
  <files>common/config/fish/functions/__completion_config.fish</files>
  <action>
Create `__completion_config.fish` with two responsibilities:

**1. Command categorization data structure:**

Migrate the existing command lists from `__smart_tab_complete.fish` into global fish lists (`set -g`) with a cleaner structure. Six categories:

```fish
set -g __cc_dir_cmds    # From existing dir_commands + additions
set -g __cc_file_cmds   # From existing file_commands + additions
set -g __cc_both_cmds   # From existing both_commands + additions
set -g __cc_git_file_subcmds  # From existing git_file_subcommands + stash
set -g __cc_native_cmds # NEW: commands that use fish native completion (never fzf)
set -g __cc_wrapper_cmds # From existing sudo/doas/env handling
```

**Base lists:** Copy all commands verbatim from `__smart_tab_complete.fish` (lines 93-151) into the corresponding `__cc_*` variables.

**Additions beyond existing lists:**

| Category | New commands | Rationale |
|----------|-------------|-----------|
| `__cc_dir_cmds` | `sshfs`, `dust` | Dir-focused tools not in current list |
| `__cc_file_cmds` | `eog`, `gimp`, `inkscape`, `libreoffice`, `soffice`, `ansible-playbook`, `terraform`, `terragrunt` | File-oriented tools |
| `__cc_both_cmds` | `unrar`, `atool`, `code`, `codium` | Accept both files and dirs |
| `__cc_native_cmds` | `git`, `docker`, `kubectl`, `systemctl`, `pacman`, `yay`, `paru`, `pip`, `cargo`, `npm`, `yarn`, `brew`, `apt`, `dnf` | Flag-heavy commands where fish native completions are richer than fzf |
| `__cc_wrapper_cmds` | (keep existing: `sudo`, `doas`, `env`, `nohup`, `nice`, `time`, `watch`, `strace`, `ltrace`) | Strip before categorization |

**Key structural change:** The `native` category is NEW. Previously, unknown commands fell through to fish default. Now, flag-heavy commands are explicitly tagged as `native` so the Tab handler can delegate to `commandline -f complete` for them, preserving fish's rich flag/subcommand completions.

Move `scp` from `__cc_file_cmds` to `__cc_both_cmds` (it accepts directories too, and remote detection is handled separately by checking for `:` in the token).

**2. Context detection function `__completion_get_type`:**

```fish
function __completion_get_type
    # Returns one of: dirs, files, both, native, trigger:ff, trigger:dd, trigger:aa, trigger:fff, trigger:fdd, trigger:faa, empty

    set -l cmd (commandline -b)
    set -l token (commandline -t)
    set -l tokens (commandline -xpc)  # Use fish's proper tokenizer (handles quoting)

    # Handle trigger words FIRST (before any other logic)
    switch "$token"
        case ff; echo "trigger:ff"; return
        case dd; echo "trigger:dd"; return
        case aa; echo "trigger:aa"; return
    end
    if string match -q -r '^f(ff|dd|aa)$' -- "$token"
        echo "trigger:$token"; return
    end

    # Empty command line -> native completion
    if test (count $tokens) -eq 0
        echo "native"; return
    end

    # Extract base command, stripping wrappers
    set -l base_cmd (basename -- $tokens[1])
    if contains $base_cmd $__cc_wrapper_cmds
        if test (count $tokens) -ge 2
            set base_cmd (basename -- $tokens[2])
        else
            echo "native"; return
        end
    end

    # If we're still on the command itself (no space after it), use native
    if test (count $tokens) -lt 2; and test -z "$token"
        echo "native"; return
    end

    # Special: git subcommand detection
    if test "$base_cmd" = git; and test (count $tokens) -ge 2
        if contains $tokens[2] $__cc_git_file_subcmds
            echo "both"; return
        end
        echo "native"; return
    end

    # Special: remote path detection (host:path pattern)
    if string match -q '*:*' -- "$token"
        # Only if a remote-capable command
        if contains $base_cmd scp rsync ssh sftp
            echo "remote"; return
        end
    end

    # Categorize by command lists
    if contains $base_cmd $__cc_native_cmds
        echo "native"
    else if contains $base_cmd $__cc_dir_cmds
        echo "dirs"
    else if contains $base_cmd $__cc_file_cmds
        echo "files"
    else if contains $base_cmd $__cc_both_cmds
        echo "both"
    else
        # Unknown command: check xdg-mime as a fallback
        # If the command is a registered MIME handler, it's likely a file opener
        if command -q xdg-mime
            set -l desktop_file (xdg-mime query default x-scheme-handler/file 2>/dev/null)
            # Check if this command appears in any .desktop file as a handler
            set -l cmd_path (command -s $base_cmd 2>/dev/null)
            if test -n "$cmd_path"; and test -f /usr/share/applications/$base_cmd.desktop
                echo "files"; return
            end
        end
        # Final default: "both" (files + dirs is safest)
        echo "both"
    end
end
```

**UX design decisions embedded in this config:**

1. **Unknown commands default to "both"** (files+dirs) rather than "native" -- because fzf is generally more useful than fish's default pager for path completion. The user gets both file and directory results, which is the safest bet for unknown commands.

2. **Fish native completions: delegation for native, NOT merged into fzf.**
   - **Decision:** Commands in `__cc_native_cmds` (git, docker, systemctl, etc.) delegate to `commandline -f complete` which shows fish's pager with flags, subcommands, and rich descriptions. These are NOT piped into fzf.
   - **Why not merge via `complete -C`?** Fish's `complete -C` output for flag-heavy commands includes flags, subcommands, descriptions -- this is structured data that fzf would flatten into plain text, losing descriptions and tab-group separation. Fish's pager handles this better.
   - **Why not merge `complete -C` path completions into fzf for dirs/files/both?** Fish's built-in path completion is a simpler, slower version of what fd already provides. Adding `complete -C` path results to our fd+zoxide+fre+history pipeline would be redundant and add latency. Our multi-source engine with frecency prioritization is strictly superior for path completion.
   - **This satisfies the "merge all sources" requirement** because: (a) for path-oriented commands, we merge 4 sources (zoxide, fre, history, fd) which is more than fish's built-in path completer, and (b) for flag-heavy commands, fish's native completions are the authoritative source and we use them directly.

3. **xdg-mime fallback for unknown commands (mimeapps integration).** When a command isn't in any manual category, we check if `$base_cmd.desktop` exists in `/usr/share/applications/`. If it does, it's a GUI app that opens files, so we return "files". This leverages the system's mimeapps/desktop file registry to auto-detect file openers without manual categorization. The manual command lists remain the primary categorization ("custom config"), and xdg-mime provides automatic coverage for any installed GUI application the lists don't cover.

4. **Trigger words checked FIRST** so they work regardless of command context. `nvim ff+Tab` works the same as `cd ff+Tab`.

5. **Wrapper stripping** handles `sudo nvim +Tab` correctly by looking past sudo to nvim.

6. **Remote detection** checks for `:` in token but ONLY for remote-capable commands, preventing false positives on paths with colons.
  </action>
  <verify>
Source the file in fish: `source common/config/fish/functions/__completion_config.fish`

Verify data structures are set:
- `echo $__cc_dir_cmds | grep -c " "` returns > 15 (many commands)
- `echo $__cc_file_cmds | grep -c " "` returns > 40

Test context detection:
- `commandline -r "cd "; __completion_get_type` -> "dirs"
- `commandline -r "nvim "; __completion_get_type` -> "files"
- `commandline -r "git add "; __completion_get_type` -> "both"
- `commandline -r "docker "; __completion_get_type` -> "native"
- `commandline -r ""; __completion_get_type` -> "native"
  </verify>
  <done>
__completion_config.fish exists with comprehensive command categorization covering 100+ commands across 5 categories (dirs, files, both, native, wrapper), trigger word detection, wrapper stripping, git subcommand handling, and remote path detection. The function __completion_get_type returns the correct type for all tested command contexts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create multi-source completion candidate engine</name>
  <files>common/config/fish/functions/__completion_sources.fish</files>
  <action>
Create `__completion_sources.fish` with the core function `__completion_sources` that generates merged, deduplicated, prioritized completion candidates.

```fish
function __completion_sources --argument-names type search_dir query_part
    # type: "dirs", "files", or "both"
    # search_dir: directory to search in (default ".")
    # query_part: partial text the user has typed (for fzf --query, not for filtering here)
    #
    # Outputs candidates to stdout, one per line, ordered by priority:
    #   1. Frecency results (zoxide for dirs, fre for files)
    #   2. Filesystem results via fd (shallow first, then deep)
    #
    # The caller pipes this into fzf.

    test -z "$search_dir"; and set search_dir "."

    set -l candidates

    switch $type
        case dirs
            # Source 1: zoxide frecency (dirs only)
            if command -q zoxide; and test "$search_dir" = "."
                # Only use zoxide for CWD-relative completion (not when searching a specific path)
                set -a candidates (zoxide query -l 2>/dev/null | head -n 30)
            end

            # Source 2: fish history paths (extract directory arguments from history)
            if test "$search_dir" = "."
                set -a candidates (builtin history search --max 500 --prefix cd 2>/dev/null | string replace -r '^cd\s+' '' | string match -r '^[~/.].*' | head -n 20)
            end

            # Source 3: fd filesystem (shallow then deep)
            set -a candidates (fd -Hi --no-ignore-vcs -t d --max-depth 1 . "$search_dir" 2>/dev/null)
            set -a candidates (fd -Hi --no-ignore-vcs -t d --min-depth 2 --max-depth 5 . "$search_dir" 2>/dev/null)

        case files
            # Source 1: fre frecency (files only)
            if command -q fre; and test "$search_dir" = "."
                set -a candidates (fre --sorted 2>/dev/null | head -n 30)
            end

            # Source 2: fish history paths (extract file arguments from history)
            if test "$search_dir" = "."
                set -a candidates (builtin history search --max 500 2>/dev/null | string replace -r '^\S+\s+' '' | string match -r '^[~/.].*\.\w+$' | head -n 20)
            end

            # Source 3: fd filesystem (shallow then deep)
            set -a candidates (fd -Hi --no-ignore-vcs -t f --max-depth 1 . "$search_dir" 2>/dev/null)
            set -a candidates (fd -Hi --no-ignore-vcs -t f --min-depth 2 --max-depth 5 . "$search_dir" 2>/dev/null)

        case both
            # Source 1: frecency (both zoxide and fre)
            if command -q zoxide; and test "$search_dir" = "."
                set -a candidates (zoxide query -l 2>/dev/null | head -n 15)
            end
            if command -q fre; and test "$search_dir" = "."
                set -a candidates (fre --sorted 2>/dev/null | head -n 15)
            end

            # Source 2: fish history paths (extract path arguments from history)
            if test "$search_dir" = "."
                set -a candidates (builtin history search --max 500 2>/dev/null | string replace -r '^\S+\s+' '' | string match -r '^[~/.].*' | head -n 20)
            end

            # Source 3: fd filesystem (shallow then deep, both types)
            set -a candidates (fd -Hi --no-ignore-vcs --max-depth 1 . "$search_dir" 2>/dev/null)
            set -a candidates (fd -Hi --no-ignore-vcs --min-depth 2 --max-depth 5 . "$search_dir" 2>/dev/null)
    end

    # Deduplicate while preserving priority order (first occurrence wins)
    printf '%s\n' $candidates | awk '!seen[$0]++'
end
```

**Key design decisions:**

1. **Frecency and history only for CWD-relative searches:** When the user types `cd ~/Doc+Tab`, they're browsing a specific directory -- zoxide/history results for unrelated paths would be noise. Frecency and history only activate when `search_dir` is `.` (no path prefix typed).

2. **Head limits on frecency results:** zoxide and fre can return thousands of entries. Limit to 30 (solo) or 15 (combined) to keep the top section meaningful without overwhelming fzf.

3. **fd max-depth 5:** Prevents scanning enormous directory trees. Shallow results (depth 1) come first for immediate relevance, deeper results follow.

4. **Deduplication preserves priority:** `awk '!seen[$0]++'` keeps the first occurrence of each path. Since frecency results come first in the list, they naturally win over duplicate fd results.

5. **Fish history as a source:** `builtin history search` provides path arguments the user has actually typed before. For dirs, we extract arguments from `cd` commands. For files, we match arguments that look like file paths (contain an extension). For both, we extract the first argument from any command. History is placed between frecency and filesystem -- more signal than raw fd but less curated than zoxide/fre. Limited to 500 history entries and 20 extracted paths to keep it fast.

6. **Graceful degradation:** If zoxide or fre aren't installed (`command -q` check), the function still works with history + fd results. This is critical for machines that may not have all tools installed yet.

7. **No caching in this layer:** fzf handles display efficiently via streaming. Caching would add complexity for marginal gain since frecency tools and fd are already fast.
  </action>
  <verify>
Source the file: `source common/config/fish/functions/__completion_sources.fish`

Test candidate generation:
- `__completion_sources dirs . "" | head -5` produces directory paths (should include zoxide results)
- `__completion_sources files . "" | head -5` produces file paths (should include fre results)
- `__completion_sources both . "" | wc -l` produces combined results (includes history paths)
- `__completion_sources dirs /tmp "" | head -3` produces directories under /tmp (no zoxide/history since not CWD)
- `__completion_sources dirs . "" | grep -c .` returns more results than `zoxide query -l | head -30 | wc -l` (history adds entries)
- `time __completion_sources dirs . ""` completes in <100ms (timing check)
  </verify>
  <done>
__completion_sources.fish exists and produces merged, deduplicated, priority-ordered completion candidates from frecency sources (zoxide/fre), fish history paths, and filesystem (fd). Priority order: frecency first, then history paths, then fd results. Function works with or without frecency tools installed. Candidate generation completes in under 100ms for typical directories.
  </done>
</task>

</tasks>

<verification>
1. Both files parse without errors: `fish -n common/config/fish/functions/__completion_config.fish` and `fish -n common/config/fish/functions/__completion_sources.fish`
2. Command categorization returns correct type for: cd (dirs), nvim (files), cp (both), docker (native), git add (both)
3. Multi-source engine returns results from frecency, fish history, and filesystem sources
4. Deduplication works: paths appearing in multiple sources (zoxide, history, fd) appear only once
5. Performance: `__completion_sources dirs . ""` completes in <100ms
</verification>

<success_criteria>
- __completion_config.fish defines categorization for 100+ commands across 6 categories with xdg-mime fallback
- __completion_get_type correctly categorizes all common command contexts, falls back to xdg-mime for unknown GUI apps
- __completion_sources merges zoxide/fre/fish history/fd results with proper deduplication
- Frecency results are prioritized (appear first in output)
- Graceful fallback when zoxide/fre not installed
- All functions pass fish syntax check
</success_criteria>

<output>
After completion, create `.planning/phases/02-fish-tab-autocomplete-robustness/02-01-SUMMARY.md`
</output>
